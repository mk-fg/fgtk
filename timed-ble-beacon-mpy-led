#!/usr/bin/env python

import asyncio, bluetooth, time, struct, hashlib as hl


class Conf:
	verbose = True
	ble_mid = 61_634 # uint16 manufacturer id to match in broadcasts
	ble_secret = b'timed-beacon-test'

	idle_sample_interval = 5.0 * 60
	idle_sample_time = 3.0
	blinky_sample_interval = 20.0
	blinky_sample_time = 4.0
	beacon_repeat_grace = 6.0 * 60 # ok to repeat counter within this td


class BLEH:

	def __init__(self):
		self.ble = bluetooth.BLE()
		self.ble.irq(self.irq_handler)
		self.scan_done = asyncio.ThreadSafeFlag()

	def __enter__(self): self.ble.active(True)
	def __exit__(self, *err): self.ble.active(False)

	def irq_handler(self, ev, data):
		if ev == 5: # scan_result
			addr_type, addr, adv_type, rssi, adv_data = data
			if adv_type != 3: return # only need adv_scan_ind
			field = self.decode_field(adv_data, 0xff) # adv_type_manufacturer
			if not field or int.from_bytes(field[:2], 'little') != self.scan_mid: return
			if len(data := bytes(field[2:])) != self.scan_data_len: return
			# XXX: should decode and check hmac here, return first **correct** packet
			self.scan_data = data; self.scan_done.set()
		elif ev == 6: self.scan_done.set() # scan_done

	def decode_field(self, pkt, ft, n=0):
		if not pkt: return
		while n + 1 < len(pkt):
			if pkt[n + 1] == ft: return pkt[n + 2 : n + pkt[n] + 1]
			n += 1 + pkt[n]

	async def sample_broadcasts( self, mid, data_len,
			duration_ms=5_000, interval_us=60_000, window_us=30_000 ):
		self.scan_mid, self.scan_data_len = mid, data_len
		self.scan_data = self.scan_done.clear()
		self.ble.gap_scan(duration_ms, interval_us, window_us)
		await self.scan_done.wait(); return self.scan_data


def hmac_sha256(key, msg):
	if len(key) > 64: key = hl.sha256(key).digest()
	key += bytes(64 - len(key))
	inner, outer = (hl.sha256(bytes(c^p for c in key)) for p in [0x36, 0x5c])
	inner.update(msg); outer.update(inner.digest())
	return outer.digest()

async def main():
	# XXX: LED task
	conf = Conf()

	# XXX: rename states to beacon/clear
	st_idle, st_blinky, timings = 0, 1, list(
		(round(s1*1000), round(s2*1000)) for s1, s2 in [
			(conf.idle_sample_interval, conf.idle_sample_time),
			(conf.blinky_sample_interval, conf.blinky_sample_time) ] )
	beacons = {st_blinky: False, st_idle: True}
	beacon_grace_td = round(conf.beacon_repeat_grace * 1000)
	st_names = {st_blinky: 'blinky', st_idle: 'idle'}
	p_log = conf.verbose and (lambda *a: print('[main]', *a))

	p_log and p_log('Starting main loop...')
	bleh, counter = BLEH(), 0
	st = st_idle; td_sleep, td_sample = timings[st]
	td_st, td_st_split, td_st_left = 0, 3, list() # XXX: configurable
	beacon, beacon_ts = False, 0
	while True:

		if beacon != beacons[st]:
			st_new = int(not st)
			p_log and p_log( 'State change'
				f' (beacon={beacon}): {st_names[st]} -> {st_names[st_new]}' )
			st = st_new; td_sleep, td_sample = timings[st]

		else:
			td = td_sleep
			if st == st_idle and beacon: # use td_st + with N rare checks in-between
				if abs(sum(td_st_left) - td_st) > td*2: td_st_left.clear() # changed/drifted
				if not td_st_left: # split td_st into chunks, check on those
					if (td_st_chunk := td_st / td_st_split) > td:
						td_st_left = [td_st_chunk + td / td_st_split] * td_st_split
				if td_st_left: td = round(td_st_left.pop() * 1000)
			elif td_st_left: td_st_left.clear() # beacon went away
			p_log and p_log(f'Delay (state={st_names[st]}): {td:,d}ms')
			await asyncio.sleep_ms(td)

		p_log and p_log(f'Scanning for broadcasts ({td_sample:,d}ms)...')
		beacon = False
		grace = (beacon_grace_td - time.ticks_diff(ts := time.ticks_ms(), beacon_ts)) > 0
		with bleh: data = await bleh.sample_broadcasts(conf.ble_mid, 26, td_sample)
		if not data: continue
		td_st, n = struct.unpack('<HL', data); td_st *= 100
		p_log and p_log(f'Scan data #{n:,d} {td_st:,d}s [ {data} ]')
		if (grace and n < counter) or n <= counter: # repeats within beacon_grace_td
			p_log and p_log(f'Replayed/reset counter: #{n:,d} <= old #{counter:,d}')
			continue
		counter, hmac = n, data[6:]
		if (hmac_chk := hmac_sha256(conf.ble_secret, data[:6])[:20]) != hmac:
			p_log and p_log(f'Bad HMAC: #{n} expected={hmac_chk} actual={hmac}'); continue
		beacon, beacon_ts = True, time.ticks_ms() # all matched

	p_log and p_log('Finished')

asyncio.run(main())
