#!/usr/bin/env python

import asyncio, bluetooth, time, struct, hashlib as hl


class Conf:
	verbose = True
	ble_mid = 61_634 # uint16 manufacturer id to match in broadcasts
	ble_secret = b'timed-beacon-test'

	# "clear" is the normal state, "beacon" is a state when those are detected
	clear_sample_interval = 20.0
	clear_sample_time = 4.0
	beacon_sample_interval = 5.0 * 60
	beacon_sample_time = 3.0
	beacon_repeat_grace = 6.0 * 60 # ok to repeat counter within this td
	beacon_span_checks = 6 # do N checks within timespan sent in the beacon


class BLEH:

	def __init__(self):
		self.ble = bluetooth.BLE()
		self.ble.irq(self.irq_handler)
		self.scan_done = asyncio.ThreadSafeFlag()

	def __enter__(self): self.ble.active(True)
	def __exit__(self, *err): self.ble.active(False)

	def irq_handler(self, ev, data):
		if ev == 5: # scan_result
			addr_type, addr, adv_type, rssi, adv_data = data
			if adv_type != 3: return # only need adv_scan_ind
			field = self.decode_field(adv_data, 0xff) # adv_type_manufacturer
			if not field or int.from_bytes(field[:2], 'little') != self.scan_mid: return
			if len(data := bytes(field[2:])) != self.scan_data_len: return
			# XXX: should decode and check hmac here, return first **correct** packet
			self.scan_data = data; self.scan_done.set()
		elif ev == 6: self.scan_done.set() # scan_done

	def decode_field(self, pkt, ft, n=0):
		if not pkt: return
		while n + 1 < len(pkt):
			if pkt[n + 1] == ft: return pkt[n + 2 : n + pkt[n] + 1]
			n += 1 + pkt[n]

	async def sample_broadcasts( self, mid, data_len,
			duration_ms=5_000, interval_us=60_000, window_us=30_000 ):
		self.scan_mid, self.scan_data_len = mid, data_len
		self.scan_data = self.scan_done.clear()
		self.ble.gap_scan(duration_ms, interval_us, window_us)
		await self.scan_done.wait(); return self.scan_data


def hmac_sha256(key, msg):
	if len(key) > 64: key = hl.sha256(key).digest()
	key += bytes(64 - len(key))
	inner, outer = (hl.sha256(bytes(c^p for c in key)) for p in [0x36, 0x5c])
	inner.update(msg); outer.update(inner.digest())
	return outer.digest()

async def main():
	# XXX: LED task
	conf = Conf()

	st_beacon, st_clear = (states := ('beacon', 'clear'))
	timings = dict(zip(states, (
		(round(s1*1000), round(s2*1000)) for s1, s2 in (
			(conf.beacon_sample_interval, conf.beacon_sample_time),
			(conf.clear_sample_interval, conf.clear_sample_time) ) )))
	beacon_grace_td = round(conf.beacon_repeat_grace * 1000)
	p_log = conf.verbose and (lambda *a: print('[main]', *a))

	p_log and p_log('Starting main loop...')
	bleh, counter = BLEH(), 0
	st = st_beacon; td_sleep, td_sample = timings[st]
	td_st, td_st_split, td_st_left = 0, conf.beacon_span_checks, list()
	beacon, beacon_ts = False, 0
	while True:
		beacon_expected = st == st_beacon

		if beacon != beacon_expected:
			st_new = st_beacon if beacon else st_clear
			p_log and p_log(f'State change (beacon={int(beacon)}): {st} -> {st_new}')
			st = st_new; td_sleep, td_sample = timings[st]

		else:
			td = td_sleep
			if beacon_expected and beacon: # use td_st + with N rare checks in-between
				if abs(sum(td_st_left) - td_st) > td*2: td_st_left.clear() # changed/drifted
				if not td_st_left: # split td_st into chunks, check on those
					if (td_st_chunk := td_st / td_st_split) > td:
						td_st_left = [td_st_chunk + td / td_st_split] * td_st_split
				if td_st_left: td = round(td_st_left.pop())
			elif td_st_left: td_st_left.clear() # beacon went away
			p_log and p_log(f'Delay (state={st}): {td:,d}ms')
			await asyncio.sleep_ms(td)

		p_log and p_log(f'Scanning for broadcasts ({td_sample:,d}ms)...')
		beacon = False
		grace = (beacon_grace_td - time.ticks_diff(ts := time.ticks_ms(), beacon_ts)) > 0
		with bleh: data = await bleh.sample_broadcasts(conf.ble_mid, 26, td_sample)
		if not data: continue
		td_st, n = struct.unpack('<HL', data); td_st *= 100_000
		p_log and p_log(f'Scan data #{n:,d} {td_st:,d}s [ {data} ]')
		if (grace and n < counter) or (not grace and n <= counter):
			p_log and p_log(f'Replayed/reset counter: #{n:,d} <= old #{counter:,d}')
			continue
		counter, hmac = n, data[6:]
		if (hmac_chk := hmac_sha256(conf.ble_secret, data[:6])[:20]) != hmac:
			p_log and p_log(f'Bad HMAC: #{n} expected={hmac_chk} actual={hmac}'); continue
		beacon, beacon_ts = True, time.ticks_ms() # all matched

	p_log and p_log('Finished')

asyncio.run(main())
