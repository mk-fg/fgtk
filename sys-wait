#!/bin/bash
set -eo pipefail

usage() {
	local bin=$(basename $0)
	[[ $1 -eq 0 ]] || exec 1>&2
	echo "Usage: $bin$(gawk \
		'/^\s+case\>/ {parse=1; m=0; next}
		/^\s+esac\>/ {exit}
		!parse {next}
		match($0, /^\s*([\-|a-zA-Z0-9]+)\)/, a) {
			if (ac==0 || ac<2) ac=""
				else ac= ac==2 ? " val" : sprintf(" val[x%s]", ac-1)
			if (ap) printf( "%s[ %s%s ]", m>2 ? "\n  " : " ", ap, ac)
			ap=a[1]; ac=0; m++ }
		{for (i=1;i<NF;i++) if (match($i, /\<shift\>/)) ac++}' $0)"
	echo
	echo "Wait until all specified system/load conditions are met."
	echo "E.g. load average value below specified threshold (--load* options)."
	echo "-p/--pgrep skips any other pgrep/pidwait processes,"
	echo "  use it multiple times for args with spaces: -p -f -p 'sleep 5'"
	echo "-I/--interval-ext-ms option adds random 0-N ms delay to each"
	echo "  interval (0-2000ms by default), to make sure they're desynced."
	echo; exit ${1:-1}; }

interval=60 interval_ext=2000
pgrep=()
load1= load5= load15=
file= file_nx=

while [[ -n "$1" ]]; do
	case "$1" in
		-h|--help) usage 0 ;;
		-x|--debug) shift; set -x ;;

		-i|--check-interval) shift; interval=$1; shift ;;
		-I|--interval-ext-ms) shift; interval_ext=$1; shift ;;

		-l|--load1) shift; load1=$1; shift ;;
		--load5) shift; load5=$1; shift ;;
		--load15) shift; load15=$1; shift ;;

		-p|--pgrep) shift; pgrep+=( "$1" ); shift ;;
		-f|--file) shift; file=$1; shift ;;
		-F|--file-nx) shift; file_nx=$1; shift ;;

		welp) exit 1 ;;
		*) echo "ERROR: Unknown option - $1"; usage 1 ;;
	esac
done


load_parse() {
	[[ "$1" =~ ^([0-9]+)(\.([0-9]+))?$ ]] || return 1
	local n=${BASH_REMATCH[1]}
	local m=${BASH_REMATCH[3]:0:2}
	[[ -n "$m" ]] || m=00
	n="$n$m"
	while [[ ${n:0:1} = 0 ]]; do n=${n:1}; done
	[[ -n "$n" ]] || n=0
	echo "$n"; }
load_test() {
	local value=$(load_parse "$1")
	local thresh=$(load_parse "$2")
	[[ "$value" -le "$thresh" ]] || return 1; }

pgrep_check() {
	[[ "${#pgrep[@]}" -eq 1 ]] && \
		local procs=( ${pgrep[0]} ) || local procs=( "${pgrep[@]}" )
	procs=$(pgrep -A -l "${procs[@]}" | grep -v ' \(pgrep\|pidwait\)$' ||:)
	[[ -z "$procs" ]] || return 1; }


(( m = ((RANDOM<<15)|RANDOM) % (interval_ext + 1) )) || m=0
(( n = m / 1000 )) || n=0; m=000$m; interval_ext=$n.${m: -3}
while :; do
	recheck=0 # 1 - delay, 2 - only random-ish interval_ext

	[[ -z "$load1" && -z "$load5" && -z "$load15" ]] || {
		read m1 m5 m15 rest < /proc/loadavg
		[[ -z "$load1" ]] || load_test "$m1" "$load1" || recheck=1
		[[ -z "$load5" ]] || load_test "$m5" "$load5" || recheck=1
		[[ -z "$load15" ]] || load_test "$m15" "$load15" || recheck=1; }

	[[ -z "$file" ]] || { [[ -e "$file" ]] || recheck=1; }
	[[ -z "$file_nx" ]] || { [[ ! -e "$file_nx" ]] || recheck=1; }
	[[ -z "$pgrep" ]] || pgrep_check || recheck=1

	[[ $recheck -ne 0 ]] || break
	if [[ $recheck -eq 1 ]]
		then sleep $interval $interval_ext
		else sleep $interval_ext; fi
done
