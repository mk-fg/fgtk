#!/usr/bin/env python3

import os, sys, json, re, math, time, pathlib as pl, subprocess as sp


class adict(dict):
	@classmethod
	def rec_make(cls, *args, _rec=id, **kws):
		v, ids, rec_key = (
			_rec if _rec is not id else (dict(*args, **kws), adict(), id) )
		if isinstance(v, (dict, list)):
			if (vid := id(v)) in ids: raise ValueError(
				f'Recursive data at [ {".".join(map(str, ids.values()))} ]' )
			if rec_key is not id: ids = adict(ids); ids[rec_key] = vid
			if isinstance(v, dict): v = cls(
				(k, cls.rec_make(_rec=(v, ids, k))) for k,v in v.items() )
			elif isinstance(v, list): v = list(
				cls.rec_make(_rec=(v, ids, f'[{n}]')) for n,v in enumerate(v) )
		return v
	def __init__(self, *args, **kws):
		super().__init__(*args, **kws)
		self.__dict__ = self

def size_repr(size, _units=list(
		reversed(list((u, 2 ** (n * 10)) for n, u in enumerate('BKMGT'))) )):
	for u, u1 in _units:
		if size > u1: break
	if u1 > 1: size = f'{size/u1:.1f}'
	return f'{size}{u}'

def td_repr(delta, units_max=2, units_res=None, _units=dict(
		h=3600, m=60, s=1, y=365.25*86400, mo=30.5*86400, w=7*86400, d=1*86400 )):
	res, s, n_last = list(), abs(delta), units_max - 1
	units = sorted(_units.items(), key=lambda v: v[1], reverse=True)
	for unit, unit_s in units:
		val = math.floor(s / unit_s)
		if not val:
			if units_res == unit: break
			continue
		if len(res) == n_last or units_res == unit:
			val, n_last = round(s / unit_s), True
		res.append(f'{val:.0f}{unit}')
		if n_last is True: break
		s -= val * unit_s
	return ' '.join(res) if res else '<1s'


def src_probe(p):
	probe = sp.run( [ 'ffprobe', '-v', 'fatal', '-show_entries',
			'stream:format=duration', '-print_format', 'json', str(p) ],
		check=True, stdout=sp.PIPE )
	probe = adict.rec_make(json.loads(probe.stdout))
	video = audio = subs = None; errs = list()
	for s in probe.streams:
		if s.codec_type == 'video':
			if video: return adict(t='video', msg='Multiple streams detected')
			if fps := s.get('avg_frame_rate') or 0:
				if '/' not in fps: fps = float(fps)
				else: a, b = map(float, fps.split('/')); fps = a/b
			video = adict(c=s.codec_name, w=s.width, h=s.height, fps=fps)
		if s.codec_type == 'audio':
			if audio: return adict(t='audio', msg='Multiple streams detected')
			br = (c := s.codec_name) == 'opus' and int(s.get('bit_rate')) or 0
			audio = adict(c=c, chans=s.channels, br=br)
		if s.codec_type == 'subtitle':
			if subs: errs.append(adict(t='subs', msg='Multiple tracks detected'))
			subs = adict(c=s.codec_name)
	if not (audio and video): return adict(t='format', msg='Missing A/V streams')
	return adict(v=video, a=audio, s=subs, td=float(probe.format.duration), errs=errs)


def main(args=None):
	import argparse, textwrap
	dd = lambda text: re.sub( r' \t+', ' ',
		textwrap.dedent(text).strip('\n') + '\n' ).replace('\t', '  ')
	parser = argparse.ArgumentParser(
		formatter_class=argparse.RawTextHelpFormatter,
		usage='%(prog)s [options] src [src ...]', description=dd('''
			ffprobe-check and convert source file(s)
				to a more compact video format, as needed, into current dir.
			Encodes to h265/opus/mkv, downscaling video/audio to ~720p30/96k-stereo.
			Initial ffprobe is intended to detect files that might already be
				converted or won't benefit from it as much, and skip those by default,
				as well as any files that can't be handled by this script correctly
				(e.g. ones that have multiple A/V streams or errors of any kind).
			Does not run conversion by default, only prints actions to be done.'''))
	parser.add_argument('src', nargs='+', help='File(s) to convert.')
	parser.add_argument('-x', '--convert', action='store_true', help=dd('''
		Run ffmpeg commands to convert all files not
			listed as PROBLEM or SKIP (unless -f/--force is used).'''))
	parser.add_argument('-f', '--force', action='store_true', help=dd('''
		Also process files marked as SKIP, i.e. ones that don't seem to need it.'''))
	parser.add_argument('-T', '--dst-dir', metavar='path', help=dd('''
		Existing path to store resulting files in. Defaults to current dir.'''))
	parser.add_argument('-n', '--name',
		metavar='tpl', default='{name}.mkv', help=dd('''
			Template to rename resulting file(s), instead of default: %(default)s
			Names are deduplicated with number-suffix when multiple sources are used.
			Substituted keys: "name" - source filename without extension.'''))
	parser.add_argument('-r', '--rm-list', metavar='file[:factor]', help=dd('''
		Generate a list of files to cleanup after conversion, one per line.
		It's realpath of all source files by default, unless but factor number
			(float in 0-1.0 range) is also specified, colon-separated after filename.
		With factor number, filename on the list is be picked
			from either source or destination after each operation,
			based on resulting filesize difference - source if resulting size
			is larger than source*factor, otherwise destination.
		Intended use is to make an easy-to-use list of files to
			rm when replacing old ones with converted versions,
			without unnecessary replacement if there's not enough benefit.'''))
	opts = parser.parse_args(sys.argv[1:] if args is None else args)

	src_list = list()
	for src in opts.src:
		try: src_list.append(src := pl.Path(src).resolve(strict=True))
		except FileNotFoundError: parser.error(f'Source path missing/inaccessible: {src}')
		if '\n' in str(src): parser.error(f'Source path with newline in it: {src!r}')
	if opts.dst_dir: os.chdir(opts.dst_dir)
	if rm_list := opts.rm_list:
		rm_list, rm_list_factor = ( (rm_list, math.inf)
			if ':' not in rm_list else rm_list.rsplit(':', 1) )
		rm_list, rm_list_factor = open(rm_list, 'w'), float(rm_list_factor)

	# Deduplication of dst filenames
	dst_name_aliases, dst_name_map = dict(), dict()
	def dst_name_format(p):
		if not (fn := dst_name_aliases.get(p)):
			fn = p.name.rsplit('.', 1)[0]
			fn = dst_name_aliases[p] = opts.name.format(name=fn) or f'{fn}.mkv'
		return fn
	for p in sorted(src_list, key=lambda p: (p.name, str(p))):
		dst_name_map.setdefault(dst_name_format(p), list()).append(p)
	for dst_name, ps in dst_name_map.items():
		if len(ps) == 1: continue
		nf = str(len(str(len(ps))))
		for n, p in enumerate(ps, 1):
			if '.' not in dst_name: fn, ext = dst_name, ''
			else: fn, ext = dst_name.rsplit('.'); ext = f'.{ext}'
			dst_name_aliases[p] = ('{}.{:0'+nf+'d}{}').format(fn, n, ext)

	# ffprobe checks
	for n, src in enumerate(src_list):
		p, dst, src_list[n] = src_probe(src), dst_name_format(src), None
		if (errs := p.get('errs')) is None:
			print(f'\n{dst} :: PROBLEM {p.get("t") or "-"} :: {p.msg}'); continue
		p.v.scale, p.v.resample = p.v.w > 1400, p.v.fps > 35
		if p.v.c == 'hevc' and not p.v.scale and not p.v.resample:
			errs.append(adict(t='video', msg='Already encoded to <1280x 30fps hevc'))
		if p.a.c == 'opus' and p.a.chans <= 2 and p.a.br and p.a.br < 200_000:
			errs.append(adict( t='audio', warn=1,
				msg='Already encoded in <200k 2ch opus, will copy it as-is' ))
			p.a.clone = True
		if errs:
			try: skip = err = next(err for err in errs if not err.get('warn'))
			except: err = errs[skip := 0]
			err_verdict = lambda: 'WARN' if err.get('warn') or opts.force else 'SKIP'
			if len(errs) > 1:
				print(f'\n{dst} :: {err_verdict()}'.rstrip())
				for err in errs: print(f'  {err_verdict()} {err.get("t") or "-"} :: {err.msg}')
			else: print(f'\n{dst} :: {err_verdict()} {err.get("t") or "-"} :: {err.msg}')
			if skip: continue
		src_list[n], p.src, p.dst = p, src, dst

	# Main ffmpeg conversion loop
	dry_run, src_list = not opts.convert, list(filter(None, src_list))
	if dry_run: print()
	for n, p in enumerate(src_list, 1):
		filters = list()
		if p.v.resample: filters.extend(['-r', '30'])
		if p.v.scale: filters.extend([
			'-filter:v', "scale='min(1280,iw)':-2,setsar=1:1" ])
		if p.a.get('clone'): ac = ['-c:a', 'copy']
		else:
			ac = ['-c:a', 'libopus', '-b:a', '96k']
			if p.a.chans == 6: ac = [ '-filter:a', # -ac2 discards sw channel
				'pan=stereo|c0=0.5*c2+0.707*c0+0.707*c4+0.5*c3'
				'|c1=0.5*c2+0.707*c1+0.707*c5+0.5*c3,volume=2.0' ] + ac
			elif p.a.chans != 2: ac = ['-ac', '2'] + ac
		movflags = ( ['-movflags', '+faststart']
			if p.dst.rsplit('.', 1)[-1].lower() in ['mp4', 'mov', 'm4v'] else [] )
		cmd = [ 'ffmpeg', '-hide_banner', '-i', str(p.src), *filters,
			'-c:v', 'libx265', '-preset', 'slow', *movflags, *ac, '-y', p.dst ]
		dt = time.strftime('%Y-%m-%d %H:%M:%S')
		msg = ( f'\n\n- {dt} --- [ {n} / {len(src_list)} ]'
			f' :: {p.src} :-[ {td_repr(p.td)} ]->: {p.dst}\n\n' )
		if dry_run: msg = msg.strip()
		print(msg); print(' '.join((repr(a) if any(
			c in a for c in '\'" ') else a) for a in cmd), end='\n\n')
		if dry_run: continue

		sp.run(cmd, check=True, stdin=sp.DEVNULL)

		# Size check, rm-list export
		target, a, b = '', os.stat(p.src).st_size, os.stat(p.dst).st_size
		if rm_list:
			improved = b/a < rm_list_factor
			rm_list.write(f'{p.src if improved else p.dst}\n'); rm_list.flush()
			if rm_list_factor is not math.inf:
				target = 'better' if improved else 'WORSE'
				target = f' [ {target} than {round(rm_list_factor*100)}% target ]'
		dt = time.strftime('%Y-%m-%d %H:%M:%S')
		print(
			f'- {dt} -- {p.dst} :: 100% -> {round((b/a) * 100)}%'
			f'{target} :: {size_repr(a)} -> {size_repr(b)}' )

if __name__ == '__main__': sys.exit(main())
